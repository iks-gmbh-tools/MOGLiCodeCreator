package com.iksgmbh.moglicc.demo.factory;

import com.iksgmbh.moglicc.demo.Person;
import java.lang.Boolean;
import java.lang.Byte;
import java.lang.Character;
import java.lang.Double;
import java.lang.Float;
import java.lang.Integer;
import java.lang.Long;
import java.lang.String;
import java.math.BigDecimal;
import java.util.Arrays;
import java.util.HashSet;
import java.util.List;
import org.joda.time.DateTime;
import java.util.*;
import org.joda.time.format.DateTimeFormatter;
import org.joda.time.format.DateTimeFormat;

import com.iksgmbh.moglicc.demo.Misc;
import com.iksgmbh.moglicc.demo.builder.MiscBuilder;
import com.iksgmbh.moglicc.demo.factory.MiscFactory;
import com.iksgmbh.moglicc.demo.utils.*;

import org.apache.commons.lang.StringUtils;

/**
* Factory class of the MOGLiCC JavaBean Group.
* Creates Misc instances with data for test purpose.
*
* @author generated by MOGLiCC
*/
public class MiscFactory
{
	private final static DateTimeFormatter dateTimeFormatter = DateTimeFormat.forPattern("dd.MM.yyyy HH:mm:ss:SSS");

	public static final int DEFAULT_MAX_LENGTH_STRING_VALUE = 1000;
	public static final int DEFAULT_MAX_LENGTH_NUMBER_VALUE = 8;
	public static final int DEFAULT_MIN_LENGTH_STRING_VALUE = 0;
	public static final int DEFAULT_MIN_LENGTH_NUMBER_VALUE = 1;
	public static final int NO_VALUE_AVAILABLE_IN_MODEL = -1;

	static final HashMap<String, List<String>> dataPool = new HashMap<String, List<String>>();
	static final HashMap<String, Integer> maxLengths = new HashMap<String, Integer>();
	static final HashMap<String, Integer> minLengths = new HashMap<String, Integer>();

	private static final String OBJECT_ID = "objectID";
	private static final Random randomizer = new Random(new Date().getTime());

	public static Integer getMaxLength(final String fieldname)
	{
		final Integer toReturn = maxLengths.get(fieldname);
		if (toReturn == null)
		{
			return NO_VALUE_AVAILABLE_IN_MODEL;
		}
		return maxLengths.get(fieldname);
	}

	public static Integer getMinLength(final String fieldname)
	{
		final Integer toReturn = minLengths.get(fieldname);
		if (toReturn == null)
		{
			return NO_VALUE_AVAILABLE_IN_MODEL;
		}
		return minLengths.get(fieldname);
	}

	/**
	 * @return the instance with all fields with maximum allowed number of chars
	 */
	public static Misc createInstanceWithAllFieldsAtMaxLength()
	{
		final Misc toReturn = new Misc();

		toReturn.setText( MOGLiFactoryUtils.createStringValue("i", getMaxLength("Text").intValue() ) );
		toReturn.setNumberByte( MOGLiFactoryUtils.createByteValue( getMaxLength("NumberByte").intValue() ) );
		toReturn.setNumberInt( MOGLiFactoryUtils.createIntValue( getMaxLength("NumberInt").intValue() ) );
		toReturn.setNumberLong( MOGLiFactoryUtils.createLongValue( getMaxLength("NumberLong").intValue() ) );
		toReturn.setNumberFloat( Float.MAX_VALUE );
		toReturn.setNumberDouble( Double.MAX_VALUE );
		toReturn.setBooleanWrapper( Boolean.TRUE );
		toReturn.setCharWrapper( Character.MAX_VALUE );
		toReturn.setByteWrapper( MOGLiFactoryUtils.createByteValue( getMaxLength("ByteWrapper").intValue() ) );
		toReturn.setIntWrapper( MOGLiFactoryUtils.createIntValue( getMaxLength("IntWrapper").intValue() ) );
		toReturn.setLongWrapper( MOGLiFactoryUtils.createLongValue( getMaxLength("LongWrapper").intValue() ) );
		toReturn.setFloatWrapper( Float.MAX_VALUE );
		toReturn.setDoubleWrapper( Double.MAX_VALUE );
		toReturn.setBigDecimal( new BigDecimal( "" + MOGLiFactoryUtils.createLongValue( getMaxLength("BigDecimal").intValue() ) ) );
		toReturn.setInstanceVariable( PersonFactory.createInstanceWithAllFieldsAtMaxLength() );

		return toReturn;
	}
	/**
	 * @return the instance with all fields with the minimum allowed number of chars
	 */
	public static Misc createInstanceWithAllFieldsAtMinLength()
	{
		final Misc toReturn = new Misc();

		toReturn.setText( MOGLiFactoryUtils.createStringValue("i", getMinLength("Text").intValue() ) );
		toReturn.setNumberByte( MOGLiFactoryUtils.createByteValue( getMinLength("NumberByte").intValue() ) );
		toReturn.setNumberInt( MOGLiFactoryUtils.createIntValue( getMinLength("NumberInt").intValue() ) );
		toReturn.setNumberLong( MOGLiFactoryUtils.createLongValue( getMinLength("NumberLong").intValue() ) );
		toReturn.setNumberFloat( Float.valueOf("0") );
		toReturn.setNumberDouble( Double.valueOf("0") );
		toReturn.setBooleanWrapper( Boolean.FALSE );
		toReturn.setCharWrapper( Character.MIN_VALUE );
		toReturn.setByteWrapper( MOGLiFactoryUtils.createByteValue( getMinLength("ByteWrapper").intValue() ) );
		toReturn.setIntWrapper( MOGLiFactoryUtils.createIntValue( getMinLength("IntWrapper").intValue() ) );
		toReturn.setLongWrapper( MOGLiFactoryUtils.createLongValue( getMinLength("LongWrapper").intValue() ) );
		toReturn.setFloatWrapper( Float.valueOf("0") );
		toReturn.setDoubleWrapper( Double.valueOf("0") );
		toReturn.setBigDecimal( new BigDecimal( "" + MOGLiFactoryUtils.createLongValue(getMinLength("BigDecimal").intValue() ) ) );
		toReturn.setInstanceVariable( PersonFactory.createInstanceWithAllFieldsAtMinLength() );

		return toReturn;
	}

	/**
	 * deletes all data except in mandatory fields
	 */
	public static void removeAllDataFromOptionalFields(final Misc instance)
	{
		instance.setText(null);
		instance.setReady(false);
		instance.setPrimitivChar( '\u0000' );
		instance.setNumberByte( (byte) 0 );
		instance.setBooleanWrapper(null);
		instance.setCharWrapper(null);
		instance.setByteWrapper(null);
		instance.setIntWrapper(null);
		instance.setLongWrapper(null);
		instance.setFloatWrapper(null);
		instance.setDoubleWrapper(null);
		instance.setBigDecimal(null);
		instance.setDateTime(null);
		instance.setListOfLongs(null);
		instance.setStringList(null);
		instance.setStringArray(null);
		instance.setHashSet(null);
	}

	public static Misc createInstanceOnlyWithMandatoryFields()
	{
		final Misc toReturn = getByIndex(0);
		removeAllDataFromOptionalFields(toReturn);
		return toReturn;
	}

	public static List<Misc> createAllFromDataPool()
	{
		final Object[] fields = dataPool.keySet().toArray();
		final int poolSize = dataPool.get(fields[0]).size();
		return createFirstFromDataPool( poolSize);
	}

	/**
	 * @param num number of Misc objects to provide
	 * @return the first <num> objects in the pool
	 */
	public static List<Misc> createFirstFromDataPool(final int num)
	{
		final int dataPoolNum = getNumberOfTestObjectsInDataPool();
		if (num > dataPoolNum)
		{
			throw new RuntimeException("Error: Cannot provide " + num + " Misc objects. Pool contains only "
                                      + dataPoolNum + " objects.");
		}

		final List<Misc> toReturn = new ArrayList<Misc>();
		for (int i = 0; i < num; i++) {
			toReturn.add(buildObject(i));
		}

		return toReturn;
	}

	/**
	 * @param num index of Misc object to provide
	 * @return the (<index>+1)th object in the pool
	 */
	public static Misc getByIndex(final int index)
	{
		final int dataPoolNum = getNumberOfTestObjectsInDataPool();
		if (index > dataPoolNum)
		{
			throw new RuntimeException("Error: Cannot provide the " + index + "th Misc object. Pool contains only "
                                     + dataPoolNum + " objects.");
		}
		return buildObject(index);
	}

	/**
	 * @param id of wanted Person object
	 * @return Person object identified by its object id
	 */
	public static Misc getById(final String objectId)
	{
		final List<String> ids = dataPool.get( OBJECT_ID );
		int indexCounter = 0;
		for (final String id : ids) {
			if ( id.equals(objectId) )
			{
				return getByIndex(indexCounter);
			}
			indexCounter++;
		}
		return null;
	}

	/**
	 * @return a randomly chosen object from the pool
	 */
	public static Misc createRandomFromDataPool()
	{
		final int limit = getNumberOfTestObjectsInDataPool();

		if (limit <= 0)
		{
			return null;  // no data available
		}

		final int index = randomizer.nextInt( limit );
		return buildObject(index);
	}

	/**
	 * Cuts the content of the named field by the numberCharToCut value if the content is not null.
	 */
	public static void cutFieldContent(final Misc instance, final String fieldname, final int numberCharToCut)
	{
		if ( "Text".equals(fieldname) )
		{
			final String value = instance.getText();

			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setText("");
				}
				else
				{
					instance.setText(value.substring(0, length));
				}
			}

			return;
		}

		if ( "NumberByte".equals(fieldname) )
		{
			final String value = "" + instance.getNumberByte();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setNumberByte( (byte) 0 );
				}
				else
				{
					instance.setNumberByte( new Byte( value.substring(0, length) ) );
				}
			}

			return;
		}

		if ( "NumberInt".equals(fieldname) )
		{
			final String value = "" + instance.getNumberInt();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setNumberInt( 0 );
				}
				else
				{
					instance.setNumberInt( new Integer( value.substring(0, length) ) );
				}
			}

			return;
		}

		if ( "NumberLong".equals(fieldname) )
		{
			final String value = "" + instance.getNumberLong();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setNumberLong( 0L );
				}
				else
				{
					instance.setNumberLong( new Long( value.substring(0, length) ) );
				}
			}

			return;
		}

		if ( "ByteWrapper".equals(fieldname) )
		{
			final String value = "" + instance.getByteWrapper();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setByteWrapper( (byte) 0 );
				}
				else
				{
					instance.setByteWrapper( new Byte( value.substring(0, length) ) );
				}
			}

			return;
		}

		if ( "IntWrapper".equals(fieldname) )
		{
			final String value = "" + instance.getIntWrapper();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setIntWrapper( 0 );
				}
				else
				{
					instance.setIntWrapper( new Integer( value.substring(0, length) ) );
				}
			}

			return;
		}

		if ( "LongWrapper".equals(fieldname) )
		{
			final String value = "" + instance.getLongWrapper();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setLongWrapper( 0L );
				}
				else
				{
					instance.setLongWrapper( new Long( value.substring(0, length) ) );
				}
			}

			return;
		}

		if ( "BigDecimal".equals(fieldname) )
		{
			final String value = "" + instance.getBigDecimal().toPlainString();
			if (value != null)
			{
				final int length = value.length() - numberCharToCut;

				if (length < 1)
				{
					instance.setBigDecimal( new BigDecimal ( "0" ) );
				}
				else
				{
					instance.setBigDecimal( new BigDecimal( value.substring(numberCharToCut) ) );
				}
			}

			return;
		}

		System.err.println("Field <" + fieldname + "> is either unkown to the class 'Misc' or cutting its field content is not supported.");
	}

	/**
	 * Appends the content of the named field by the textToAdd value if the content is not null.
    * This value must represent a number for numerical fields.
	 */
	public static void addToFieldContent(final Misc instance, final String fieldname, final String textToAdd)
	{
		if ( "Text".equals(fieldname) )
		{
			final String value = instance.getText();

			if (value != null)
			{
				instance.setText(value + textToAdd);
			}

			return;
		}

		if ( "NumberByte".equals(fieldname) )
		{
			final String value = "" + instance.getNumberByte() + textToAdd;
			instance.setNumberByte( new Byte( value ).byteValue() );
			return;
		}

		if ( "NumberInt".equals(fieldname) )
		{
			final String value = "" + instance.getNumberInt() + textToAdd;
			instance.setNumberInt( new Integer( value ).intValue() );
			return;
		}

		if ( "NumberLong".equals(fieldname) )
		{
			final String value = "" + instance.getNumberLong() + textToAdd;
			instance.setNumberLong( new Long( value ).longValue() );
			return;
		}

		if ( "ByteWrapper".equals(fieldname) )
		{
			if (instance.getByteWrapper() != null)
			{
				final String value = "" + instance.getByteWrapper() + textToAdd;
				instance.setByteWrapper( new Byte( value ) );
			}

			return;
		}

		if ( "IntWrapper".equals(fieldname) )
		{
			if (instance.getIntWrapper() != null)
			{
				final String value = "" + instance.getIntWrapper() + textToAdd;
				instance.setIntWrapper( new Integer( value ) );
			}

			return;
		}

		if ( "LongWrapper".equals(fieldname) )
		{
			if (instance.getLongWrapper() != null)
			{
				final String value = "" + instance.getLongWrapper() + textToAdd;
				instance.setLongWrapper( new Long( value ) );
			}

			return;
		}

		if ( "BigDecimal".equals(fieldname) )
		{
			if (instance.getBigDecimal() != null)
			{
				final String value = textToAdd + instance.getBigDecimal().toPlainString() + textToAdd;
				instance.setBigDecimal( new BigDecimal( value ) );
			}

			return;
		}

		System.err.println("Field <" + fieldname + "> is either unkown to the class 'Misc' or appending its field content is not supported.");
	}

   // *************************************************************************
   // ***************************  private methods  ***************************
   // *************************************************************************

	private static String getValue(final String field, final int index)
	{
		final List<String> list = dataPool.get(field);
		if (list == null)
		{
			throw new RuntimeException("Unkown field '" + field + "' in class 'Misc'.");
		}

		if (index >= list.size())
		{
			return null;  // no value for this index available
		}

		return list.get(index);
	}

	private static Misc buildObject(final int index)
	{
		MiscBuilder builder = new MiscBuilder();
		String value = null;
		value = getValue("Text", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withText( value );

		value = getValue("Ready", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withReady( new Boolean( value ).booleanValue() );

		value = getValue("PrimitivChar", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withPrimitivChar( value.charAt(0) );

		value = getValue("NumberByte", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withNumberByte( new Byte( value ).byteValue() );

		value = getValue("NumberInt", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withNumberInt( new Integer( value ).intValue() );

		value = getValue("NumberLong", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withNumberLong( new Long( value ).longValue() );

		value = getValue("NumberFloat", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withNumberFloat( new Float( value ).floatValue() );

		value = getValue("NumberDouble", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withNumberDouble( new Double( value ).doubleValue() );

		value = getValue("BooleanWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withBooleanWrapper( new Boolean( value ) );

		value = getValue("CharWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withCharWrapper( value.charAt(0) );

		value = getValue("ByteWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withByteWrapper( new Byte( value ) );

		value = getValue("IntWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withIntWrapper( new Integer( value ) );

		value = getValue("LongWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withLongWrapper( new Long( value ) );

		value = getValue("FloatWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withFloatWrapper( new Float( value ) );

		value = getValue("DoubleWrapper", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withDoubleWrapper( new Double( value ) );

		value = getValue("BigDecimal", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withBigDecimal( new BigDecimal( "" + value ) );

		value = getValue("DateTime", index);
		if ( ! StringUtils.isEmpty( value ) )
			builder = builder.withDateTime( dateTimeFormatter.parseDateTime( value ) );

		builder = builder.withListOfLongs( CollectionsStringUtils.commaSeparatedStringToLongList( getValue("ListOfLongs", index) ) );

		builder = builder.withStringList( CollectionsStringUtils.commaSeparatedStringToStringList( getValue("StringList", index) ) );

		builder = builder.withStringArray( CollectionsStringUtils.commaSeparatedStringToStringArray( getValue("StringArray", index) ) );

		builder = builder.withHashSet( CollectionsStringUtils.commaSeparatedStringToHashSet( getValue("HashSet", index) ) );

		value = getValue("InstanceVariable", index);
		final Person instanceVariable = PersonFactory.getById( value );
		builder = builder.withInstanceVariable( instanceVariable );

		return builder.build();
	}

	static int getNumberOfTestObjectsInDataPool()  {
		final String firstKey = MiscFactory.dataPool.keySet().iterator().next();
		return MiscFactory.dataPool.get(firstKey).size();
	}

	/**
	 * Calls createInstanceWithAllFieldsAtMaxLength and addToFieldContent to fields of supported JavaType
	 * (these are: byte, Byte, int, Integer, double, Double, String, java.math.BigDecimal,
    * if MaxLength-metainfo is defined for the corresponding attribute in the data model.
	 * @return instance that causes validation exceptions for the supported fields.
	 */
	public static Misc createInstanceWithAllSupportedFieldsExceedingMaxLength()
	{
		final Misc toReturn = createInstanceWithAllFieldsAtMaxLength();

		addToFieldContent(toReturn, "Text", "9");
		addToFieldContent(toReturn, "NumberByte", "9");
		addToFieldContent(toReturn, "ByteWrapper", "9");
		addToFieldContent(toReturn, "LongWrapper", "9");
		addToFieldContent(toReturn, "BigDecimal", "9");

		return toReturn;
	}

	/**
	 * Calls createInstanceWithAllFieldsAtMinLength and cutFieldContent to fields of supported JavaType
	 * (these are; byte, Byte, int, Integer, double, Double, String, java.math.BigDecimal),
	 * if MinLength-metainfo is defined for the corresponding attribute in the data model.
	 * @return instance that causes validation exceptions for the corresponding fields.
	 */
	public static Misc createInstanceWithAllSupportedFieldsNotReachingMinLength()
	{
		final Misc toReturn = createInstanceWithAllFieldsAtMinLength();

		cutFieldContent(toReturn, "Text", 1);
		cutFieldContent(toReturn, "BigDecimal", 1);

		return toReturn;
	}

	static
	{
		// fill data pool
		final List<String> textList = new ArrayList<String>();
		textList.add("Textinhalt 2");
		textList.add("Textinhalt 3");
		dataPool.put("Text", textList);

		final List<String> readyList = new ArrayList<String>();
		readyList.add("true");
		readyList.add("false");
		dataPool.put("Ready", readyList);

		final List<String> primitivCharList = new ArrayList<String>();
		primitivCharList.add("b");
		primitivCharList.add("a");
		dataPool.put("PrimitivChar", primitivCharList);

		final List<String> numberByteList = new ArrayList<String>();
		numberByteList.add("10");
		numberByteList.add("22");
		dataPool.put("NumberByte", numberByteList);

		final List<String> numberIntList = new ArrayList<String>();
		numberIntList.add("20");
		numberIntList.add("303");
		dataPool.put("NumberInt", numberIntList);

		final List<String> numberLongList = new ArrayList<String>();
		numberLongList.add("30");
		numberLongList.add("2121212");
		dataPool.put("NumberLong", numberLongList);

		final List<String> numberFloatList = new ArrayList<String>();
		numberFloatList.add("23.45");
		numberFloatList.add("34.56");
		dataPool.put("NumberFloat", numberFloatList);

		final List<String> numberDoubleList = new ArrayList<String>();
		numberDoubleList.add("12.34");
		numberDoubleList.add("1234.34");
		dataPool.put("NumberDouble", numberDoubleList);

		final List<String> booleanWrapperList = new ArrayList<String>();
		booleanWrapperList.add("true");
		booleanWrapperList.add("false");
		dataPool.put("BooleanWrapper", booleanWrapperList);

		final List<String> charWrapperList = new ArrayList<String>();
		charWrapperList.add("B");
		charWrapperList.add("A");
		dataPool.put("CharWrapper", charWrapperList);

		final List<String> byteWrapperList = new ArrayList<String>();
		byteWrapperList.add("10");
		byteWrapperList.add("5");
		dataPool.put("ByteWrapper", byteWrapperList);

		final List<String> intWrapperList = new ArrayList<String>();
		intWrapperList.add("20");
		intWrapperList.add("74");
		dataPool.put("IntWrapper", intWrapperList);

		final List<String> longWrapperList = new ArrayList<String>();
		longWrapperList.add("3000");
		longWrapperList.add("500055");
		dataPool.put("LongWrapper", longWrapperList);

		final List<String> floatWrapperList = new ArrayList<String>();
		floatWrapperList.add("1.343");
		floatWrapperList.add("1.343");
		dataPool.put("FloatWrapper", floatWrapperList);

		final List<String> doubleWrapperList = new ArrayList<String>();
		doubleWrapperList.add("13.345");
		doubleWrapperList.add("12.343");
		dataPool.put("DoubleWrapper", doubleWrapperList);

		final List<String> bigDecimalList = new ArrayList<String>();
		bigDecimalList.add("123.4322");
		bigDecimalList.add("123.4323");
		dataPool.put("BigDecimal", bigDecimalList);

		final List<String> dateTimeList = new ArrayList<String>();
		dateTimeList.add("15.12.2013 18:39:11:231");
		dateTimeList.add("25.10.2008 12:00:59:999");
		dataPool.put("DateTime", dateTimeList);

		final List<String> listOfLongsList = new ArrayList<String>();
		listOfLongsList.add("1, 2, 3");
		listOfLongsList.add("1, 2, 3, 4");
		dataPool.put("ListOfLongs", listOfLongsList);

		final List<String> stringListList = new ArrayList<String>();
		stringListList.add("a a, b b, c c");
		stringListList.add("a a, b b, c c, d d");
		dataPool.put("StringList", stringListList);

		final List<String> stringArrayList = new ArrayList<String>();
		stringArrayList.add("a a, b b, c c");
		stringArrayList.add("a a, b b, c c, d d");
		dataPool.put("StringArray", stringArrayList);

		final List<String> hashSetList = new ArrayList<String>();
		hashSetList.add("a a, b b, c c");
		hashSetList.add("a a, b b, c c, d d");
		dataPool.put("HashSet", hashSetList);

		final List<String> instanceVariableList = new ArrayList<String>();
		instanceVariableList.add("Person1");
		instanceVariableList.add("Person2");
		dataPool.put("InstanceVariable", instanceVariableList);

		final List<String> objectIdList = new ArrayList<String>();
		objectIdList.add( "Misc1" );
		objectIdList.add( "Misc2" );
		dataPool.put(OBJECT_ID, objectIdList);

		// set maxLength values
		maxLengths.put("Text", new Integer( 50 ));
		maxLengths.put("NumberByte", new Integer( 1 ));
		maxLengths.put("NumberInt", new Integer( DEFAULT_MAX_LENGTH_NUMBER_VALUE ));
		maxLengths.put("NumberLong", new Integer( DEFAULT_MAX_LENGTH_NUMBER_VALUE ));
		maxLengths.put("ByteWrapper", new Integer( 1 ));
		maxLengths.put("IntWrapper", new Integer( DEFAULT_MAX_LENGTH_NUMBER_VALUE ));
		maxLengths.put("LongWrapper", new Integer( 7 ));
		maxLengths.put("BigDecimal", new Integer( 9 ));

		// set minLength values
		minLengths.put("Text", new Integer( 4 ));
		minLengths.put("NumberByte", new Integer( DEFAULT_MIN_LENGTH_NUMBER_VALUE ));
		minLengths.put("NumberInt", new Integer( DEFAULT_MIN_LENGTH_NUMBER_VALUE ));
		minLengths.put("NumberLong", new Integer( DEFAULT_MIN_LENGTH_NUMBER_VALUE ));
		minLengths.put("ByteWrapper", new Integer( DEFAULT_MIN_LENGTH_NUMBER_VALUE ));
		minLengths.put("IntWrapper", new Integer( DEFAULT_MIN_LENGTH_NUMBER_VALUE ));
		minLengths.put("LongWrapper", new Integer( DEFAULT_MIN_LENGTH_NUMBER_VALUE ));
		minLengths.put("BigDecimal", new Integer( 3 ));
	}

}
